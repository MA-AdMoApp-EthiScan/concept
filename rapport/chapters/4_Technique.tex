\section{Techniques}

\subsection{Quoi et Comment}

EthiScan implémente un système de scan de code-barres qui identifie les produits et récupère des informations à partir de bases de données externes via des API. L'application traite ces données pour afficher les informations pertinentes aux utilisateurs, telles que les labels, l'évolution des prix, et l'impact carbone.

\subsection{Problèmes Rencontrés et Solutions}

\paragraph{Version des dépendances} Lors du développement, nous avons rencontré un problème majeur lié à la gestion des versions de Flutter utilisées par les différents membres de l'équipe. En effet, nous avons constaté qu'une personne utilisait la version 3.22 de Flutter, tandis que d'autres travaillaient avec la version 3.19. Cette disparité de versions a causé des conflits lors de l'intégration de nouvelles dépendances. Par exemple, certaines dépendances étaient compatibles avec une version de Flutter mais pas avec l'autre, ce qui a entraîné des erreurs de compilation. La synchronisation des versions de Flutter entre tous les membres de l'équipe s'est avérée difficile. Nous avions le choix entre downgrade Flutter ou de résoudre les conflits avec la dernière version. Nous avons opté pour la deuxième option, car elle nous permettait de bénéficier des dernières fonctionnalités et correctifs de Flutter. Cependant, cela a nécessité un effort supplémentaire pour résoudre les conflits et garantir la compatibilité des dépendances avec la version la plus récente de Flutter.

\paragraph{Structure de l'application} Nous avons décidé de suivre les bonnes pratiques de la "clean architecture" ce qui a posé plusieurs défis. Comme chaque membre de l'équipe avait une expérience différente Flutter, nous avons tous développé des portions de code de manière indépendante, en utilisant des approches et des structures différentes, souvent inspirées d'exemples trouvés en ligne ou de projets précédents. L'intégration de ces morceaux de code disparates dans un cadre uniforme basé sur la clean architecture a nécessité des efforts significatifs. Nous avons dû refactorer et harmoniser les différentes méthodes de développement pour les aligner avec les principes de la clean architecture, ce qui a parfois causé des problèmes d'intégration et ralenti le développement de nouvelles features. Cette étape a souligné l'importance de définir dès le départ une architecture claire et partagée par toute l'équipe pour faciliter le développement collaboratif. Au final, nous avons utilisé le package "clean\_architecture" pour structurer notre application.

\paragraph{Gestion des états} Un autre défi a été la gestion des blocs, en particulier avec les pages de connexion et d'inscription. Initialement, nous avions un mainUserBloc chargé de l'authentification et de la gestion des données utilisateur dans toute l'application. Cependant, l'intégration des pages de connexion et d'inscription a posé problème. Ces pages, conçues pour fonctionner indépendamment, ne s'intégraient pas bien dans la structure de l'application en raison de problèmes liés aux locales de traduction. Pour contourner ce problème, nous avons décidé de placer ces pages directement dans le fichier app.dart, en dehors de la structure principale de l'application. Cette décision a introduit des complications avec le main user bloc, entraînant des conflits entre les blocs de gestion d'état. Bien que nous ayons finalement trouvé une solution. TODO Quelle solution ? Comment on a fix ce truc ?

\paragraph{Versionnement du code} Nous avons rencontré quelques problèmes avec l'utilisation de GitHub au sein de notre équipe. L'un des membres, ne maîtrisant pas GitHub, a effectué tout son travail sur une branche existante déjà mergée sur la principale (main), sans jamais fusionner ses modifications. Par conséquent, le reste de l'équipe n'a pas pu suivre l'avancement de son travail. Au moment de fusionner sa branche, nous avons découvert le problème. Cela a posé des problèmes d'intégration car le code sur main avait été largement restructuré entre-temps. Pour résoudre cette situation, nous avons résolu les conflits de versions progressivement jusqu'au succès. Puis, nous avons formé toute l'équipe à l'utilisation de GitHub. Désormais, chaque nouvelle tâche doit être accompagnée de la création d'une issue et d'une branche correspondante. Une fois la tâche terminée et approuvée, la branche est fusionnée dans la branche principale avec un code review. Cette approche, combinée à une meilleure communication entre les membres de l'équipe, a permis d'éviter les problèmes.

\subsection{Conclusion Technique}

La combinaison de Flutter et Firebase a prouvé son efficacité pour développer une application mobile performante et réactive. L'architecture choisie a permis une mise en œuvre rapide des fonctionnalités tout en maintenant une haute qualité et fiabilité des données.

\subsection{Auto-Critique du Code}

\subsubsection{Points Positifs}
\begin{itemize}
    \item Code bien structuré et commenté, facilitant la maintenance et les mises à jour.
    \item Utilisation efficace des patterns de conception pour une architecture solide.
\end{itemize}

\subsubsection{Points à Améliorer}
\begin{itemize}
    \item Couverture des tests unitaires à augmenter pour assurer une meilleure stabilité.
    \item Optimisation possible de certaines requêtes de données pour accélérer les temps de réponse.
\end{itemize}